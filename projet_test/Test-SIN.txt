use oscillateur_lib::Oscillateur;
fn main() {
    let mut osc = Oscillateur::new(440.0, 0.0, 44100.0, 1024); // Crée un oscillateur avec un buffer de taille 1024
    let mut x = 0; // Compteur pour simuler l'axe x

    // Boucle infinie pour générer et afficher les échantillons
    loop {
        let sample = osc.generate_and_get_next_sample();
        println!("Sample {}: {}", x, sample);

        x += 1;  // Incrémentation de l'index après chaque échantillon

        // Pause pour simuler un taux d'échantillonnage en temps réel et éviter de saturer la sortie
        std::thread::sleep(std::time::Duration::from_millis(10));
    }
}
---------------------------------------------------------------------------------------------------------------------------
--------------affichage en mode tableau mais une fois le code fini et avec un nombre d'echantillons predefini--------------
---------------------------------------------------------------------------------------------------------------------------
use oscillateur_lib::Oscillateur;
use std::thread;
use std::time::Duration;

fn main() {
    let mut osc = Oscillateur::new(440.0, 0.0, 44100.0, 1024); // Crée un oscillateur avec un buffer de taille 1024
    let nombre_echantillons = 1000; // Définissez le nombre d'échantillons à générer
    let mut echantillons = Vec::new(); // Vecteur pour stocker les échantillons

    for _ in 0..nombre_echantillons {
        let echantillon = osc.generate_and_get_next_sample();
        echantillons.push(echantillon); // Ajoute l'échantillon au vecteur
        thread::sleep(Duration::from_millis(10)); // Pause pour simuler un taux d'échantillonnage en temps réel
    }

    // Imprimer tous les échantillons dans un format de tableau JSON
    println!("[{}]", echantillons.iter().map(|&x| x.to_string()).collect::<Vec<_>>().join(", "));
}
---------------------------------------------------------------------------------------------------------------------------
------------------------------------------------- son  --------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use dasp::Sample;
use crossbeam::channel;
use std::io;

use oscillateur_lib::Oscillateur; // Assurez-vous que le chemin est correct

fn main() -> Result<(), anyhow::Error> {
    let host = cpal::default_host();
    let device = host.default_output_device().ok_or(anyhow::Error::msg("No output device found"))?;
    let config = device.default_output_config()?.config();

    // Crée un oscillateur avec la fréquence spécifiée, une phase de zéro, et le taux d'échantillonnage
    let sample_rate = config.sample_rate.0 as f64; // Convertit u32 en f64
    let frequency = read_frequency()?; // Lire la fréquence depuis l'entrée utilisateur
    let mut osc = Oscillateur::new(frequency, 0.0, sample_rate, 1024);

    let (stop_sender, stop_receiver) = channel::bounded::<()>(1);

    let err_fn = |err| eprintln!("An error occurred on the output audio stream: {}", err);

    // Prépare un canal de diffusion sonore
    let stream = device.build_output_stream(
        &config,
        move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
            for sample in data.iter_mut() {
                *sample = osc.generate_and_get_next_sample().to_sample::<f32>();
            }
            // Vérifiez si un signal d'arrêt a été reçu
            if stop_receiver.try_recv().is_ok() {
                // Si un signal d'arrêt est reçu, arrêtez la lecture
                std::process::exit(0);
            }
        },
        err_fn,
        None,
    )?;

    stream.play()?;

    // Attendez que l'utilisateur appuie sur Entrée pour arrêter le flux
    println!("Press Enter to stop playback...");
    let _ = read_stop_signal();

    // Envoyer un signal pour arrêter la diffusion
    stop_sender.send(())?;

    Ok(())
}

fn read_stop_signal() -> Result<(), io::Error> {
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(())
}

fn read_frequency() -> Result<f64, io::Error> {
    println!("Enter the frequency (Hz):");
    let mut freq_input = String::new();
    io::stdin().read_line(&mut freq_input)?;
    let freq_hz: f64 = freq_input.trim().parse().unwrap_or(440.0); // Default to 440 Hz if parse fails
    Ok(freq_hz)
}
---------------------------------------------------------------------------------------------------------------------------
------------------------------------------------- son  --------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use dasp::Sample;
use crossbeam::channel;
use std::io;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

use oscillateur_lib::Oscillateur; // Assurez-vous que le chemin est correct

fn main() -> Result<(), anyhow::Error> {
    let host = cpal::default_host();
    let device = host.default_output_device().ok_or(anyhow::Error::msg("No output device found"))?;
    let config = device.default_output_config()?.config();

    // Crée un oscillateur avec la fréquence spécifiée, une phase de zéro, et le taux d'échantillonnage
    let sample_rate = config.sample_rate.0 as f64; // Convertit u32 en f64
    let frequency = read_frequency()?; // Lire la fréquence depuis l'entrée utilisateur
    let osc = Arc::new(Mutex::new(Oscillateur::new(frequency, 0.0, sample_rate, 1024)));

    let (stop_sender, stop_receiver) = channel::bounded::<()>(1);
    let echantillons = Arc::new(Mutex::new(Vec::new()));

    let osc_for_thread = Arc::clone(&osc);
    let echantillons_for_thread = Arc::clone(&echantillons);
    let err_fn = |err| eprintln!("An error occurred on the output audio stream: {}", err);

    // Prépare un canal de diffusion sonore
    let stream = device.build_output_stream(
        &config,
        move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
            let mut osc = osc_for_thread.lock().unwrap();
            let mut echantillons = echantillons_for_thread.lock().unwrap();
            for sample in data.iter_mut() {
                let gen_sample = osc.generate_and_get_next_sample();
                *sample = gen_sample.to_sample::<f32>();
                echantillons.push(gen_sample); // Stocker chaque échantillon généré
            }
            // Vérifiez si un signal d'arrêt a été reçu
            if stop_receiver.try_recv().is_ok() {
                // Si un signal d'arrêt est reçu, arrêtez la lecture
                std::process::exit(0);
            }
        },
        err_fn,
        None,
    )?;

    stream.play()?;

    // Attendez que l'utilisateur appuie sur Entrée pour arrêter le flux
    println!("Press Enter to stop playback...");
    let _ = read_stop_signal();

    // Envoyer un signal pour arrêter la diffusion
    stop_sender.send(())?;

    // Afficher les échantillons après la fin de la diffusion sonore
    let echantillons = echantillons.lock().unwrap();
    println!("[{}]", echantillons.iter().map(|&x| x.to_string()).collect::<Vec<_>>().join(", "));

    Ok(())
}

fn read_stop_signal() -> Result<(), io::Error> {
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(())
}

fn read_frequency() -> Result<f64, io::Error> {
    println!("Enter the frequency (Hz):");
    let mut freq_input = String::new();
    io::stdin().read_line(&mut freq_input)?;
    let freq_hz: f64 = freq_input.trim().parse().unwrap_or(440.0); // Default to 440 Hz if parse fails
    Ok(freq_hz)
}


---------------------------------------------------------------------------------------------------------------------------
----------------------------------affichage en mode tableau  une fois le code fini ----------------------------------------
---------------------------------------------------------------------------------------------------------------------------

use Oscilator_Mod_sin::OscillateurSin;

use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
use std::io;


fn main() {
    let osc = Arc::new(Mutex::new(OscillateurSin::new(440.0, 0.0, 44100.0, 1024)));
    let nombre_echantillons = 1000;
    let echantillons = Arc::new(Mutex::new(Vec::new()));
    let running = Arc::new(Mutex::new(true));

    let osc_clone = Arc::clone(&osc);
    let samples_clone = Arc::clone(&echantillons);
    let running_clone = Arc::clone(&running);

    // Thread pour générer les échantillons
    let generator = thread::spawn(move || {
        while *running_clone.lock().unwrap() {
            let mut osc = osc_clone.lock().unwrap();
            if samples_clone.lock().unwrap().len() < nombre_echantillons {
                let sample = osc.generate_and_get_next_sample();
                samples_clone.lock().unwrap().push(sample);
                thread::sleep(Duration::from_millis(10));
            } else {
                break;
            }
        }
    });

    println!("Press Enter to stop playback...");
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    *running.lock().unwrap() = false;
    generator.join().unwrap();

    // Afficher les échantillons générés
    let samples = echantillons.lock().unwrap();
    println!("[{}]", samples.iter().map(|&x| x.to_string()).collect::<Vec<_>>().join(", "));
}

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------




use oscillator_module::Oscillator;
fn main() {
    let mut buffer = [0.0; 255];
    let mut obj = Oscillator::new(440.0, 0.0, 44100.0, &mut buffer);
    let mut output = String::new(); // Utilise une String pour collecter les sorties

    for i in 0..9 {
        let buffer = obj.process();
        for j in 0..buffer.len() {
            output.push_str(&format!("Loop {}: subloop: {}: sample {}\n", i, j, buffer[j]));
        }
    }

    println!("{}", output); // Imprime toutes les sorties en une fois
}
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------


use oscillator_module::Oscillator;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
use std::io;

fn main() {
    let mut buffer = [0.0; 255];
    let osc = Arc::new(Mutex::new(Oscillator::new(440.0, 0.0, 44100.0, &mut buffer)));
    let running = Arc::new(Mutex::new(true));
    let output = Arc::new(Mutex::new(String::new())); // Pour stocker les résultats de manière thread-safe

    let osc_clone = Arc::clone(&osc);
    let output_clone = Arc::clone(&output);
    let running_clone = Arc::clone(&running);

    // Thread pour générer et collecter les échantillons
    let generator = thread::spawn(move || {
        let mut loops = 0;
        while *running_clone.lock().unwrap() && loops < 9 { // Limite à 9 boucles
            let buffer = osc_clone.lock().unwrap().process();
            let mut out = output_clone.lock().unwrap();
            for j in 0..buffer.len() {
                out.push_str(&format!("Loop {}: subloop: {}: sample {}\n", loops, j, buffer[j]));
            }
            loops += 1;
            thread::sleep(Duration::from_millis(10)); // Simule le traitement ou l'attente
        }
    });

    println!("Press Enter to stop playback...");
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    *running.lock().unwrap() = false;
    generator.join().unwrap();

    // Imprimer tous les échantillons générés
    let output = output.lock().unwrap();
    println!("{}", *output);
}
