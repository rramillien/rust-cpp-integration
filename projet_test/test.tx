use oscillateur_lib::Oscillateur;
fn main() {
    let mut osc = Oscillateur::new(440.0, 0.0, 44100.0, 1024); // Crée un oscillateur avec un buffer de taille 1024
    let mut x = 0; // Compteur pour simuler l'axe x

    // Boucle infinie pour générer et afficher les échantillons
    loop {
        let sample = osc.generate_and_get_next_sample();
        println!("Sample {}: {}", x, sample);

        x += 1;  // Incrémentation de l'index après chaque échantillon

        // Pause pour simuler un taux d'échantillonnage en temps réel et éviter de saturer la sortie
        std::thread::sleep(std::time::Duration::from_millis(10));
    }
}
use oscillateur_lib::Oscillateur;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;
use std::time::Duration;



fn main() {
    let mut osc = Oscillateur::new(440.0, 0.0, 44100.0, 1024);
    if let Err(e) = osc.play() {
        println!("Failed to start audio stream: {:?}", e);
        return;
    }

    println!("Audio stream started successfully. Press ENTER to stop.");
    osc.start_playing();

    // Wait for the user to press ENTER to stop the playback
    let osc_clone = osc.clone();
    thread::spawn(move || {
        let mut input = String::new();
        let _ = std::io::stdin().read_line(&mut input);
        osc_clone.stop_playing();
    });

    // Keep the main thread alive while the audio is playing
    while osc.is_playing() {
        thread::sleep(Duration::from_secs(1));
    }

    println!("Audio stream stopped.");
}